import{e as J}from"./Segment-70e0f05f.js";import{aq as D,c8 as K,kU as g,kV as L,kW as Q,a_ as tt,kX as et,b2 as nt,gq as at,gp as st,kY as it,kZ as rt,k_ as G,bm as F}from"./index-888ef8d4.js";const gt={readOnly:!0,get(){return J(this.view)}};var x;(function(t){t[t.Auto=0]="Auto",t[t.Euclidean=1]="Euclidean",t[t.Geodesic=2]="Geodesic"})(x||(x={}));function O(t){if(!t)return null;if(L(t)&&t.wkid){const e=Q[t.wkid];if(e)return e}if(t.wkt){const e=ot(t.wkt);if(e)return e}return null}function ot(t){const e=et.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const a=parseFloat(n[1]),s=parseFloat(n[2]);return isNaN(a)||isNaN(s)?null:{a,f:s===0?0:1/s}}function ct(t){const e=O(t??tt.WGS84);if(ht(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function ht(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function lt(t){return O(t)!==null}function vt(t,e="meters"){if(!t)throw new D("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(a=>!lt(a.spatialReference)))throw new D("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let a=0;a<t.length;a++){const s=t[a],{spatialReference:m}=s,v=s.type==="polyline"?s.paths:s.rings;let r=0;for(let _=0;_<v.length;_++){const o=v[_];let f=0;for(let p=1;p<o.length;p++){const z=o[p-1][0],k=o[p][0],w=o[p-1][1],h=o[p][1];if(w!==h||z!==k){const c=new ut;ft(c,[z,w],[k,h],m),f+=c.distance}}r+=f}r=K(r,"meters",e),n.push(r)}return n}class ut{constructor(e=0,n=void 0,a=void 0){this.distance=e,this.azimuth=n,this.reverseAzimuth=a}}function ft(t,e,n,a){const s=e[0]*g,m=e[1]*g,v=n[0]*g,r=n[1]*g,{a:_,b:o,f,radius:p}=ct(a),z=v-s,k=Math.atan((1-f)*Math.tan(m)),w=Math.atan((1-f)*Math.tan(r)),h=Math.sin(k),c=Math.cos(k),R=Math.sin(w),l=Math.cos(w);let y,$,M,i,A,q,U,b,N,P,S=1e3,u=z;do{if(U=Math.sin(u),b=Math.cos(u),M=Math.sqrt(l*U*(l*U)+(c*R-h*l*b)*(c*R-h*l*b)),M===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;A=h*R+c*l*b,q=Math.atan2(M,A),N=c*l*U/M,$=1-N*N,i=A-2*h*R/$,isNaN(i)&&(i=0),P=f/16*$*(4+f*(4-3*$)),y=u,u=z+(1-P)*f*N*(q+P*M*(i+P*A*(2*i*i-1)))}while(Math.abs(u-y)>1e-12&&--S>0);if(S===0){const V=p,X=Math.acos(Math.sin(m)*Math.sin(r)+Math.cos(m)*Math.cos(r)*Math.cos(v-s))*V,j=v-s,Y=Math.sin(j)*Math.cos(r),Z=Math.cos(m)*Math.sin(r)-Math.sin(m)*Math.cos(r)*Math.cos(j),B=Math.atan2(Y,Z);return t.azimuth=B/g,t.distance=X,t.reverseAzimuth=void 0,t}const d=$*(_*_-o*o)/(o*o),E=d/1024*(256+d*(d*(74-47*d)-128)),C=o*(1+d/16384*(4096+d*(d*(320-175*d)-768)))*(q-E*M*(i+E/4*(A*(2*i*i-1)-E/6*i*(4*M*M-3)*(4*i*i-3)))),H=Math.atan2(l*Math.sin(u),c*R-h*l*Math.cos(u)),I=Math.atan2(c*Math.sin(u),c*R*Math.cos(u)-h*l);return t.azimuth=H/g,t.distance=C,t.reverseAzimuth=I/g,t}function _t(t,e){if(nt(e,0,0,0),t.length>0){for(let n=0;n<t.length;++n)at(e,e,t[n]);st(e,e,1/t.length)}}function Rt(t,e,n,a){a.projectToRenderScreen(t,T),a.projectToRenderScreen(e,W),it(n,Mt,pt),rt(n,n)}const T=G(),pt=T,W=G(),Mt=W;class zt{constructor(e=null){this.spatialReference=e}get spatialReference(){return this._spatialReference}set spatialReference(e){e!==this._spatialReference&&(this._spatialReference=e,this._updateNormalizationFactors())}normalizeDistance(e){return e*this._metersPerDistanceUnit}normalizeElevation(e){return e*this._metersPerElevationUnit}normalizeArea(e){return e*this._squareMetersPerAreaUnit}_updateNormalizationFactors(){this._metersPerDistanceUnit=F(this._spatialReference,1),this._metersPerElevationUnit=F(this._spatialReference,1),this._squareMetersPerAreaUnit=this._metersPerDistanceUnit*this._metersPerDistanceUnit}}export{lt as M,ut as R,gt as a,ft as b,_t as c,x as e,Rt as f,zt as t,vt as y};
