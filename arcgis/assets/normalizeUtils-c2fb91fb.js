import{cg as D,ei as U,by as X,cn as F,c0 as W,ia as _,ib as B,b3 as E,eM as G,dv as H,c2 as P,ic as O,ak as v,id as K,aq as Q}from"./index-888ef8d4.js";import{r as N,o as A,i as R,s as C}from"./normalizeUtilsCommon-ff02416d.js";async function V(t,s,c,n){const e=D(t),f=s[0].spatialReference,a={...n,query:{...e.query,f:"json",sr:JSON.stringify(f),target:JSON.stringify({geometryType:U(s[0]),geometries:s}),cutter:JSON.stringify(c)}},o=await X(e.path+"/cut",a),{cutIndexes:u,geometries:y=[]}=o.data;return{cutIndexes:u,geometries:y.map(h=>{const x=F(h);return x.spatialReference=f,x})}}async function Y(t,s,c){const n=typeof t=="string"?W(t):t,e=s[0].spatialReference,f=U(s[0]),a={...c,query:{...n.query,f:"json",sr:e.wkid??JSON.stringify(e),geometries:JSON.stringify(_(s))}},{data:o}=await X(n.path+"/simplify",a);return B(o.geometries,f,e)}const T=E.getLogger("esri.geometry.support.normalizeUtils");function Z(t){return t.type==="polygon"}function tt(t){return t[0].type==="polygon"}function et(t){return t[0].type==="polyline"}function st(t,s){if(!(t instanceof P||t instanceof v)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw T.error(e),new Q(e)}const c=A(t),n=[];for(const e of c){const f=[];n.push(f),f.push([e[0][0],e[0][1]]);for(let a=0;a<e.length-1;a++){const o=e[a][0],u=e[a][1],y=e[a+1][0],h=e[a+1][1],x=Math.sqrt((y-o)*(y-o)+(h-u)*(h-u)),l=(h-u)/x,m=(y-o)/x,p=x/s;if(p>1){for(let b=1;b<=p-1;b++){const S=b*s,i=m*S+o,r=l*S+u;f.push([i,r])}const w=(x+Math.floor(p-1)*s)/2,j=m*w+o,I=l*w+u;f.push([j,I])}f.push([y,h])}}return Z(t)?new v({rings:n,spatialReference:t.spatialReference}):new P({paths:n,spatialReference:t.spatialReference})}function z(t,s,c){if(s){const n=st(t,1e6);t=K(n,!0)}return c&&(t=C(t,c)),t}function k(t,s,c){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<c){const e=R(n,c);t[0]=n+e*(-2*c)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<c){const e=R(n,c);t=t.clone().offset(e*(-2*c),0)}}return t}function nt(t,s){let c=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],f=s.geometries[n],a=A(f);for(let o=0;o<a.length;o++){const u=a[o];u.some(y=>{if(y[0]<180)return!0;{let h=0;for(let l=0;l<u.length;l++){const m=u[l][0];h=m>h?m:h}h=Number(h.toFixed(9));const x=-360*R(h,180);for(let l=0;l<u.length;l++){const m=f.getPoint(o,l);f.setPoint(o,l,m.clone().offset(x,0))}return!0}})}if(e===c){if(tt(t))for(const o of A(f))t[e]=t[e].addRing(o);else if(et(t))for(const o of A(f))t[e]=t[e].addPath(o)}else c=e,t[e]=f}return t}async function ot(t,s,c){if(!Array.isArray(t))return ot([t],s);s&&typeof s!="string"&&T.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??G.geometryServiceUrl;let e,f,a,o,u,y,h,x,l=0;const m=[],p=[];for(const i of t)if(i!=null)if(e||(e=i.spatialReference,f=H(e),a=e.isWebMercator,y=a?102100:4326,o=N[y].maxX,u=N[y].minX,h=N[y].plus180Line,x=N[y].minus180Line),f)if(i.type==="mesh")p.push(i);else if(i.type==="point")p.push(k(i.clone(),o,u));else if(i.type==="multipoint"){const r=i.clone();r.points=r.points.map(g=>k(g,o,u)),p.push(r)}else if(i.type==="extent"){const r=i.clone()._normalize(!1,!1,f);p.push(r.rings?new v(r):r)}else if(i.extent){const r=i.extent,g=R(r.xmin,u)*(2*o);let d=g===0?i.clone():C(i.clone(),g);r.offset(g,0),r.intersects(h)&&r.xmax!==o?(l=r.xmax>l?r.xmax:l,d=z(d,a),m.push(d),p.push("cut")):r.intersects(x)&&r.xmin!==u?(l=r.xmax*(2*o)>l?r.xmax*(2*o):l,d=z(d,a,360),m.push(d),p.push("cut")):p.push(d)}else p.push(i.clone());else p.push(i);else p.push(i);let w=R(l,o),j=-90;const I=w,b=new P;for(;w>0;){const i=360*w-180;b.addPath([[i,j],[i,-1*j]]),j*=-1,w--}if(m.length>0&&I>0){const i=nt(m,await V(n,m,b,c)),r=[],g=[];for(let $=0;$<p.length;$++){const q=p[$];if(q!=="cut")g.push(q);else{const M=i.shift(),L=t[$];L!=null&&L.type==="polygon"&&L.rings&&L.rings.length>1&&M.rings.length>=L.rings.length?(r.push(M),g.push("simplify")):g.push(a?O(M):M)}}if(!r.length)return g;const d=await Y(n,r,c),J=[];for(let $=0;$<g.length;$++){const q=g[$];q!=="simplify"?J.push(q):J.push(a?O(d.shift()):d.shift())}return J}const S=[];for(let i=0;i<p.length;i++){const r=p[i];if(r!=="cut")S.push(r);else{const g=m.shift();S.push(a===!0?O(g):g)}}return S}export{ot as b};
